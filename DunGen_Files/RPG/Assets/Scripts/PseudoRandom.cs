using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Security.Cryptography;
using System.Text;

public class PseudoRandom : MonoBehaviour {

    /*
     * --------------------------------------
     *           THE DETERMINISTIC
     *      PSEUDORANDOM NUMBER GENERATOR
     * --------------------------------------
     * 
     * This PRNG is used to feed random initial values into the Procedural Generation Controller component.
     * Using a seed derived from a user-provided string, it uses Lagged Fibonacci RNG to produce a sequence of random numbers
     * It then mods this value by the required amount so as to always return a value inside the specified range.
     * 
     * The idea here is that we always want to get the same dungeons for the same seed value. New seed, new dungeons.
     * So instead of using C# and Unity's default RNG we write our own. 
     * This is done as both a method of controlling the values produced and a mathematical exercise.
     * 
     * randomInit is called to begin the process.
     *      This takes the MD5 hash of the provided string, and reads a substring of that as hex to get an integer seed
     *      From this integer seed, we use the Lehmer algorithm to produce the first 10 random values.
     *      (because Lagged Fibonacci relies on past, existing values)
     *      Once this is done, every new random number is generated by taking items 10 and 7 numbers behind the current, and returning their sum modded by a constant
     *      
     */

    private int random_current;
    private int int_seed;
    
    private bool seeded;
    private List<int> latest_values;

    // Lehmer initialization constants
    // The relation between m and a is important enough that we don't try to generate them procedurally. These are our constants.
    private const int m = 2147483647;
    private const int a = 48271;  // 
    private const int q = 44488;  // m / a
    private const int r = 3399;  // m % a



    public int f_h; // Larger Fibonacci index
    public int f_l; // Smaller Fibonacci index
    public MD5 hasher;
    public string seed;
    public int digits;
    public int max;

    void Start () {
        // sentinel values since in practice they will always be positive integers.
        // If they're still -1 during operation we know something got screwed up somewhere along the way
        random_current = -1;
        int_seed = -1;
        seeded = false;
        hasher = MD5.Create();

        //randomInit(hasher, seed, digits);
        //for (int i = 0; i < 10; i++) {
        //    Debug.Log("Cycle #" + i + ": " + getRandom());
        //}

    }
	
	// Update is called once per frame
	void Update () {
		
	}


    public void randomInit(MD5 hasher, string seed, int digits) {
        hasher = MD5.Create();
        // set the max value
        //Debug.Log("Max set to " + max);


        // Read the seed as bytes and compute the hash
        byte[] seedBytes = Encoding.ASCII.GetBytes(seed);
        byte[] hashedSeed = hasher.ComputeHash(seedBytes);

        // Stringbuilder for storing the string constructed from the hashed bytes
        StringBuilder sBuilder = new StringBuilder();

        for (int i = 0; i < hashedSeed.Length; i++) {
            sBuilder.Append(hashedSeed[i].ToString("x2"));
        }

        string seed_md5 = sBuilder.ToString();

        // 16^3 = 4096 possible unique dungeons!
        string adder_str = seed_md5.Substring(1, 2); 
        int_seed = System.Convert.ToInt32(adder_str, 16);

        //Debug.Log("The seed " + seed + " got hashed to "+ sBuilder.ToString());
        //Debug.Log("Integer seed is " + int_seed);

        // generate the first ten values using Lehmer RNG
        latest_values = new List<int>();
        int current = int_seed; // current value

        for(int i = 0; i < f_h+1; i++) {
            int high = current / f_h;
            int low = current % f_h;
            int t = (a * low) - (r * high);

            if (t > 0) {
                current = t;
            }
            else {
                current = t + m;
            }

            //Debug.Log("Initial value#" + i + ": " + current);
            latest_values.Add(current);
        }
        // We are now seeded and set to go!
        seeded = true;
        // "burn" the first 512 values just to make sure.
        for (int x = 0; x < 512; x++) {
            getRandom();
        }

        
    }
    


    public int getRandom() {
        if (!seeded) {
            Debug.LogError("Cannot get random number as random is not yet initiated");
        }
        int left = latest_values[0] % m;
        int right = latest_values[f_h - f_l] % m;
        long sum = (long)left + (long)right;

        random_current = (int)(sum % m);
        latest_values.Insert(f_h + 1, random_current);
        latest_values.RemoveAt(0);
        return (random_current % max);
        /*return 4; // chosen by fair dice roll. guaranteed to be random. https://xkcd.com/221/ */
    }

    public int getRandomRanged(int max) {
        if (!seeded) {
            Debug.LogError("Cannot get random number as random is not yet initiated");
        }
        int left = latest_values[0] % m;
        int right = latest_values[f_h - f_l] % m;
        long sum = (long)left + (long)right;

        random_current = (int)(sum % m);
        latest_values.Insert(f_h + 1, random_current);
        latest_values.RemoveAt(0);
        return (random_current % max);
        /*return 4; // chosen by fair dice roll. guaranteed to be random. https://xkcd.com/221/ */
    }

    // get a randnum where min <= randnum <= max
    public int getRandint(int min, int max) {
        max += 1;
        if (!seeded) {
            Debug.LogError("Cannot get random number as random is not yet initiated");
        }
        int left = latest_values[0] % m;
        int right = latest_values[f_h - f_l] % m;
        long sum = (long)left + (long)right;

        random_current = (int)(sum % m);
        latest_values.Insert(f_h + 1, random_current);
        latest_values.RemoveAt(0);
        int retval = random_current % (max - min);
        retval += min;
        return retval;
    }


}
